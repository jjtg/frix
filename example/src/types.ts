import type { Generated, ColumnType } from 'kysely';

// ============================================================================
// TYPE UNWRAPPING UTILITY
// ============================================================================

/**
 * Unwrap Kysely types to their primitive "select" form.
 * This extracts the underlying type from Kysely's ColumnType and Generated wrappers.
 *
 * - Generated<T> → T
 * - ColumnType<Select, Insert, Update> → Select
 * - Primitive types → unchanged
 */
type Unwrap<T> = T extends ColumnType<infer S, unknown, unknown> ? S : T;

/**
 * Unwrap all fields in a database row type.
 * Makes the row type match what you receive from SELECT queries.
 */
type UnwrapRow<Row> = {
  [K in keyof Row]: Unwrap<Row[K]>;
};

// ============================================================================
// TABLE TYPES (with Generated<T> for auto-generated columns)
// ============================================================================

/**
 * Database table definition for users.
 *
 * Uses Generated<T> to mark columns that are auto-generated by the database.
 * This tells Kysely/Frix that these fields are optional on INSERT.
 *
 * @example
 * ```typescript
 * // When inserting, id and created_at are optional:
 * await userRepo.create({
 *   email: 'user@example.com',
 *   name: 'John Doe',
 *   status: 'ACTIVE',
 *   // id and created_at are auto-generated
 * });
 * ```
 */
export interface UserTable {
  /** Auto-generated primary key */
  id: Generated<number>;
  /** User's email address (unique) */
  email: string;
  /** User's display name */
  name: string;
  /** Account status - ACTIVE or INACTIVE */
  status: 'ACTIVE' | 'INACTIVE';
  /** Timestamp when the user was created */
  created_at?: Generated<Date>;
}

/**
 * Unwrapped user type - what you get back from queries.
 *
 * Frix automatically unwraps Generated<T> types, so query results
 * have plain types (number instead of Generated<number>).
 *
 * @example
 * ```typescript
 * const user = await userRepo.findById(1);
 * // user.id is number, not Generated<number>
 * // user.created_at is Date | undefined, not Generated<Date>
 * ```
 */
export type User = UnwrapRow<UserTable>;

/**
 * Database table definition for posts.
 *
 * Represents a blog post or article created by a user.
 */
export interface PostTable {
  /** Auto-generated primary key */
  id: Generated<number>;
  /** Foreign key referencing users.id */
  user_id: number;
  /** Post title */
  title: string;
  /** Post content (nullable) */
  content: string | null;
  /** Whether the post is published (defaults to false) */
  published?: Generated<boolean>;
  /** Timestamp when the post was created */
  created_at?: Generated<Date>;
}

/**
 * Unwrapped post type - what you get back from queries.
 */
export type Post = UnwrapRow<PostTable>;

/**
 * Database schema definition for Kysely.
 *
 * Maps table names to their corresponding table interfaces.
 * Used to provide type safety for all database operations.
 */
export interface Database {
  /** Users table */
  users: UserTable;
  /** Posts table */
  posts: PostTable;
}

// ============================================================================
// DTO TYPES (for API responses - camelCase convention)
// ============================================================================

/**
 * User DTO for API responses.
 *
 * Demonstrates the convention-based snake_case to camelCase mapping
 * that AutoMapper handles automatically.
 */
export interface UserDTO {
  id: number;
  email: string;
  name: string;
  status: 'ACTIVE' | 'INACTIVE';
  createdAt?: Date;
}

/**
 * Post DTO for API responses.
 */
export interface PostDTO {
  id: number;
  userId: number;
  title: string;
  content: string | null;
  published?: boolean;
  createdAt?: Date;
}

/**
 * User summary DTO - demonstrates CustomMapper with transformation logic.
 */
export interface UserSummaryDTO {
  id: number;
  displayName: string;
  isActive: boolean;
}
