# Frix Example Project

A comprehensive example demonstrating all features of the frix library - your TypeScript repository pattern for Kysely.

## Prerequisites

- Node.js 18+
- Docker (for PostgreSQL)

## Quick Start

```bash
# 1. Start the database
docker-compose up -d

# 2. Install dependencies and run migrations
npm install
npm run migrate

# 3. Run the demo
npm run demo
```

## Project Structure

```
example/
├── migrations/           # Kysely migrations
│   ├── 001_create_users.ts
│   └── 002_create_posts.ts
├── src/
│   ├── database.ts       # Database connection with logging
│   ├── types.ts          # Table types, DTOs, and unwrapped types
│   ├── repositories/     # Repository factories using .extend<T>()
│   │   ├── user-repository.ts
│   │   ├── post-repository.ts
│   │   └── index.ts
│   ├── mappers/          # DTO mapping examples
│   │   ├── user-mapper.ts
│   │   ├── post-mapper.ts
│   │   └── index.ts
│   └── demo.ts           # Comprehensive demo of all features
├── docker-compose.yml    # PostgreSQL setup
├── kysely.config.ts      # Kysely CLI configuration
└── package.json
```

## Features Demonstrated

### 1. Database Connection with Query Logging

```typescript
import { createDatabase } from 'frix';

export function getDatabase(enableLogging = false) {
  return createDatabase<Database>({
    host: 'localhost',
    port: 5432,
    user: 'frix',
    password: 'frix',
    database: 'frix_example',
    pool: { max: 10 },
    log: enableLogging, // Built-in query logging
  });
}

// Usage:
const db = getDatabase(true); // Enable SQL logging
// Output: [QUERY] SELECT * FROM users WHERE id = $1 (5ms)
```

### 2. Type-Safe Complex Queries with `.extend<T>()`

Define interfaces for your complex queries and let Frix auto-implement them:

```typescript
import { createRepository } from 'frix';
import type { Database, User } from '../types.js';

// Define complex query method signatures
interface UserQueries {
  findByEmailAndStatus(email: string, status: string): Promise<User | undefined>;
  findAllByIdGreaterThan(id: number): Promise<User[]>;
  findAllByStatusIn(statuses: string[]): Promise<User[]>;
  findAllByEmailLike(pattern: string): Promise<User[]>;
  findAllByStatusOrderByNameAsc(status: string): Promise<User[]>;
}

// Create repository with type-safe extensions
export function createUserRepository(db: Kysely<Database>) {
  return createRepository(db, 'users').extend<UserQueries>();
}

// Usage - full autocomplete and type safety!
const userRepo = createUserRepository(db);
const user = await userRepo.findByEmailAndStatus('alice@example.com', 'ACTIVE');
const users = await userRepo.findAllByStatusOrderByNameAsc('ACTIVE');
```

### 3. Type Unwrapping with `Generated<T>`

Frix automatically unwraps `Generated<T>` types from Kysely:

```typescript
import type { Generated } from 'kysely';
import type { Unwrap } from 'frix';

// Table type with Generated fields (for inserts)
interface UserTable {
  id: Generated<number>;           // Auto-generated by DB
  email: string;
  name: string;
  status: 'ACTIVE' | 'INACTIVE';
  created_at?: Generated<Date>;    // Auto-generated timestamp
}

// Unwrapped type for application use (query results)
type User = Unwrap<UserTable>;
// Result: { id: number; email: string; name: string; ... }

// Query results are automatically unwrapped
const user = await userRepo.findById(1);
// user.id is number, not Generated<number>
```

### 4. DTO Mapping

#### AutoMapper - Convention-based snake_case ↔ camelCase

```typescript
import { AutoMapper } from 'frix';

interface UserRow {
  id: number;
  user_name: string;
  created_at: Date;
}

interface UserDTO {
  id: number;
  userName: string;
  createdAt: Date;
}

const mapper = new AutoMapper<UserRow, UserDTO>();

// Convert database row to DTO
const dto = mapper.toDto(row);    // { userName: '...', createdAt: ... }

// Convert DTO back to row
const row = mapper.toRow(dto);    // { user_name: '...', created_at: ... }

// Batch conversion using map()
const dtos = rows.map(row => mapper.toDto(row));
```

#### CustomMapper - Custom Transformation Logic

```typescript
import { CustomMapper } from 'frix';

interface UserSummaryDTO {
  id: number;
  displayName: string;
  isActive: boolean;
}

const summaryMapper = new CustomMapper<User, UserSummaryDTO>({
  toDto: (user) => ({
    id: user.id,
    displayName: user.name,
    isActive: user.status === 'ACTIVE',
  }),
  toRow: (dto) => ({
    id: dto.id,
    email: '',
    name: dto.displayName,
    status: dto.isActive ? 'ACTIVE' : 'INACTIVE',
  }),
});
```

### 5. Basic CRUD Operations

```typescript
// Create
const user = await userRepo.create({
  email: 'alice@example.com',
  name: 'Alice',
  status: 'ACTIVE',
});

// Read
const found = await userRepo.findById(user.id);
const all = await userRepo.findAll();

// Update
const updated = await userRepo.update(user.id, { name: 'Alice Smith' });

// Delete
const deleted = await userRepo.delete(user.id);

// Save (upsert)
const saved = await userRepo.save({ ...user, name: 'Alice Updated' });
```

### 6. Derived Finders

Auto-generated finder methods based on method naming:

```typescript
// Single result finders
const user = await userRepo.findByEmail('test@example.com');

// Multi-result finders
const users = await userRepo.findAllByStatus('ACTIVE');

// Multi-column finders (AND condition)
const user = await userRepo.findByEmailAndStatus('test@example.com', 'ACTIVE');
```

### 7. Comparison Operators

```typescript
// Greater than / Less than
const users = await userRepo.findAllByIdGreaterThan(100);
const users = await userRepo.findAllByIdLessThan(50);

// IN operator
const users = await userRepo.findAllByStatusIn(['ACTIVE', 'PENDING']);

// LIKE operator
const users = await userRepo.findAllByEmailLike('%@example.com');

// IS NULL
const users = await userRepo.findAllByDeletedAtIsNull();
```

### 8. Ordering and Pagination

```typescript
// Order by ascending
const users = await userRepo.findAllByStatusOrderByNameAsc('ACTIVE');

// Order by descending
const users = await userRepo.findAllByStatusOrderByCreatedAtDesc('ACTIVE');

// Pagination with options
const users = await userRepo.findAllByStatus('ACTIVE', {
  limit: 10,
  offset: 20,
});
```

### 9. Batch Operations

```typescript
// Create many
const users = await userRepo.createMany([
  { email: 'user1@test.com', name: 'User 1', status: 'ACTIVE' },
  { email: 'user2@test.com', name: 'User 2', status: 'ACTIVE' },
]);

// Create many without returning rows (faster for large inserts)
const count = await userRepo.createMany(users, { skipReturn: true });

// Update many by criteria
const count = await userRepo.updateMany(
  { status: 'PENDING' },
  { status: 'ACTIVE' }
);

// Delete many by criteria
const count = await userRepo.deleteMany({ status: 'INACTIVE' });
```

### 10. Query Builder Extensions

```typescript
// Count rows
const total = await userRepo.count();
const active = await userRepo.count({ status: 'ACTIVE' });

// Check existence (efficient with LIMIT 1)
const hasUsers = await userRepo.exists();
const hasActive = await userRepo.exists({ status: 'ACTIVE' });

// Custom query with full Kysely builder
const results = await userRepo.query()
  .where('created_at', '>', someDate)
  .where('status', '=', 'ACTIVE')
  .orderBy('name', 'asc')
  .limit(10)
  .execute();
```

### 11. Transactions

```typescript
import { withTransaction, TransactionScope } from 'frix';

await withTransaction(db, async (scope: TransactionScope<Database>) => {
  const userRepo = scope.getRepository('users');
  const postRepo = scope.getRepository('posts');

  const user = await userRepo.create({ ... });
  await postRepo.create({ user_id: user.id, ... });

  // All operations commit together or rollback on error
});
```

### 12. Error Handling

```typescript
import { RepositoryError } from 'frix';

try {
  await userRepo.create({ email: 'duplicate@example.com', ... });
} catch (error) {
  if (error instanceof RepositoryError) {
    console.log('Error code:', error.code);
    console.log('Message:', error.message);
  }
}
```

### 13. Integrated Repository Mapping (`.withMapper()`)

Create repositories that automatically convert between database rows and DTOs:

```typescript
import { createRepository, AutoMapper } from 'frix';

// Define row (snake_case) and DTO (camelCase) types
interface UserRow {
  id: number;
  user_name: string;
  created_at: Date;
}

interface UserDTO {
  id: number;
  userName: string;
  createdAt: Date;
}

// Create a mapped repository
const userDtoRepo = createRepository(db, 'users')
  .withMapper(new AutoMapper<UserRow, UserDTO>());

// All read operations return DTOs automatically
const users = await userDtoRepo.findAll();        // UserDTO[]
const user = await userDtoRepo.findById(1);       // UserDTO | null
const active = await userDtoRepo.findAllByStatus('ACTIVE'); // UserDTO[]

// Write operations accept DTOs
const newUser = await userDtoRepo.create({
  userName: 'Alice',  // camelCase - automatically converted to snake_case
  status: 'ACTIVE',
});

// Criteria operations work with DTO-style keys
const count = await userDtoRepo.count({ userName: 'Alice' });
const exists = await userDtoRepo.exists({ status: 'ACTIVE' });

// Access raw repository when needed
const rawUser = await userDtoRepo.raw.findById(1);  // snake_case Row
```

#### Chaining with `.extend<T>()`

`.withMapper()` is a terminal operation and must be last in the chain:

```typescript
interface UserQueries {
  findByEmailAndStatus(email: string, status: string): Promise<UserDTO | null>;
}

// Correct: extend first, then withMapper
const repo = createRepository(db, 'users')
  .extend<UserQueries>()
  .withMapper(new AutoMapper<UserRow, UserDTO>());

// Now custom queries also return DTOs
const user = await repo.findByEmailAndStatus('alice@example.com', 'ACTIVE');
```

#### Using CustomMapper for Complex Transformations

```typescript
import { CustomMapper } from 'frix';

const summaryMapper = new CustomMapper<UserRow, UserSummaryDTO>({
  toDto: (row) => ({
    id: row.id,
    displayName: row.user_name,
    isActive: row.status === 'ACTIVE',
  }),
  toRow: (dto) => ({
    id: dto.id,
    user_name: dto.displayName,
    status: dto.isActive ? 'ACTIVE' : 'INACTIVE',
    // ... other required fields
  }),
});

const summaryRepo = createRepository(db, 'users')
  .withMapper(summaryMapper);

const summaries = await summaryRepo.findAll();  // UserSummaryDTO[]
```

## Creating Your Own Repositories

### 1. Define Types

```typescript
// src/types.ts
import type { Generated } from 'kysely';
import type { Unwrap } from 'frix';

export interface ProductTable {
  id: Generated<number>;
  name: string;
  price: number;
  category: string;
  created_at: Generated<Date>;
}

export type Product = Unwrap<ProductTable>;

export interface Database {
  products: ProductTable;
}
```

### 2. Create Repository with Extensions

```typescript
// src/repositories/product-repository.ts
import type { Kysely } from 'kysely';
import { createRepository } from 'frix';
import type { Database, Product } from '../types.js';

interface ProductQueries {
  findAllByCategory(category: string): Promise<Product[]>;
  findAllByPriceLessThan(price: number): Promise<Product[]>;
  findAllByCategoryOrderByPriceAsc(category: string): Promise<Product[]>;
}

export function createProductRepository(db: Kysely<Database>) {
  return createRepository(db, 'products').extend<ProductQueries>();
}
```

### 3. Use Repository

```typescript
const productRepo = createProductRepository(db);

// Built-in methods
const product = await productRepo.findById(1);
const allProducts = await productRepo.findAll();

// Extended methods - fully typed!
const cheap = await productRepo.findAllByPriceLessThan(100);
const electronics = await productRepo.findAllByCategoryOrderByPriceAsc('electronics');
```

## Database Setup

### Using Docker (Recommended)

```bash
docker-compose up -d
```

This starts PostgreSQL 15 with:
- Host: localhost
- Port: 5432
- User: frix
- Password: frix
- Database: frix_example

### Migrations

Run migrations:
```bash
npm run migrate
```

Rollback:
```bash
npm run migrate:down
```

## Troubleshooting

### Database Connection Failed

Make sure PostgreSQL is running:
```bash
docker-compose ps
```

Check logs:
```bash
docker-compose logs postgres
```

### Migration Errors

Reset database:
```bash
docker-compose down -v
docker-compose up -d
npm run migrate
```

### TypeScript Errors with `.extend<T>()`

If your IDE shows errors for `.extend<T>()`, try:
1. Invalidate caches and restart the TypeScript service
2. Ensure you're using the latest version of frix
3. Check that your interface methods follow the naming conventions

## License

MIT
